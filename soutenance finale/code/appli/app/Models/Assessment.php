<?php

namespace App\Models;

use App\Models\Writers\AssessmentWriter;
use App\Models\Writers\LogWriter;
use Exception;
use Illuminate\Database\Eloquent\Model;

/**
 * An Assessment is what an Expert annotate according to a Topic. He may annotate
 * it in its globality with a GlobalTag, or all the words in it with some WordTag,
 * or both. An Assessment can be a Snippet or a Document as well. A snippet is
 * generated by the search engine based on a document and a topic. That's why
 * Snippet inherits from Document, and Document inherits from Assessment. They are
 * both Assessment and Snippet is a Document in a more accurate form. For the same
 * document, several snippets can be generated according to the given topic.
 */
abstract class Assessment extends Model
{
    /**
     * The raw content of this Assessment.
     *
     * @var String
     */
    protected String $_content;

    /**
     * The annotable abstract is the part of the abstract that is actually
     * annotable by an expert. It is the same litteral string as the abstract
     * but we have kept the alphanumeric characters only.
     *
     * @access protected
     * @var String
     */
    protected String $_annotable_abstract;

    /**
     * The words of the abstract are nested in span elements. Each of them has a
     * clickable or non-clickable class depending on whether the word in the span
     * is clickable or not.
     *
     * @access protected
     * @var String
     */
    protected String $_parsed_abstract;

    /**
     * Constructs a new Assessment.
     */
    public function __construct()
    {
        /**
         * Call Models's constructor.
         */
        parent::__construct();
    }

    //*********************
    //***   UTILITIES   ***
    //*********************

    /**
     * Removes every special characters except blank spaces. Then, replace all
     * multiples spaces by a single one.
     *
     * @return String The abstract without special character and single spaced.
     * It forms the words actually annotable.
     */
    private function annotableAbstract(): String
    {
        return preg_replace(
            $pattern = '!\s+!',
            $replacement = ' ',
            $subject = str_replace(
                $search = Settings::$SEPARATORS_NOSPACE,
                $replace = '',
                $subject = $this->_content
            )
        );
    }

    /**
     * Constructs the parsed abstract of this Assessment.
     *
     * @return String The abstract parsed to make it usable by the blade view.
     */
    private function parseAbstract(): String
    {
        /**
         * Last index of the next word we are looking for.
         */
        $last = 0;
        /**
         * Allows us to alternate between function calls. We start depending on whether
         * the string starts with a clickable character or not.
         */
        $alt = in_array($this->_content[0], Settings::$SEPARATORS);
        $res = ""; //result

        while (true) {
            $first = $last;
            $last = $alt ? $this->nextGoodChar($first) : $this->nextBlankChar($first);

            if ($last == -1) {
                $res = $res . "<span" . ($alt ? ">" : " class=\"clic\">") . substr($this->_content, $first) . "</span>";
                return $res;
            } else {
                $res = $res . "<span" . ($alt ? ">" : " class=\"clic\">") . substr($this->_content, $first, $last - $first) . "</span>";
            }
            $alt = !$alt; //we alternate...
        }
    }

    /**
     * Gets the next clickable char index from the index in parameter.
     *
     * @param int $i The index from which we start searching.
     * @return int The index of the next clickable char. Returns -1 if EOL happens before.
     */
    private function nextGoodChar(int $i): int
    {
        $idx = $i + 1;
        while (true) {
            if ($idx > strlen($this->_content) - 1)
                return -1;
            if (in_array($this->_content[$idx], Settings::$SEPARATORS) ||
            !in_array($this->_content[$idx], Settings::$SEPARATORS) && in_array($this->_content[$idx + 1], Settings::$SEPARATORS)) {
                $idx++;
            } else {
                return $idx;
            }
        }
    }

    /**
     * Gets the next non-clickable char index from the index in parameter.
     *
     * @param int $i The index from which we start searching.
     * @return int The index of the next non-clickable char. Returns -1 if EOL happens before.
     */
    private function nextBlankChar(int $i): int
    {
        $idx = $i + 1;
        while (true) {
            if ($idx > strlen($this->_content) - 1)
                return -1;
            if (!in_array($this->_content[$idx], Settings::$SEPARATORS)) {
                $idx++;
            } else {
                return $idx;
            }
        }
    }

    //*********************
    //***    QUERIES    ***
    //*********************

    /**
     * Exports all the completed or remaining Assessments. The exported File name contains
     * the Campaign's target which can be "snippets" or "documents" but never both at the same
     * time. Campaign's type can be either "global", "words", or "globalwords". If it is
     * "globalwords", two files must be exported, one for the words, and one for the global
     * annotations.
     *
     * @param String $content_type The content_type of the Assessment file (if it is remaining or
     * completed files). It can be either "completed" or "remaining".
     *
     * @return array|String|false Writes one or two files depending on the Campaign's type.
     * Returns the file name if this was a success (array if there is two filenames to return,
     * String if there is only one), false otherwise.
     */
    public static function exportAssessments(String $content_type): array|String|false
    {
        /**
         * Check illegal arguments
         */
        if ($content_type != "completed" && $content_type != "remaining")
            throw new Exception("Invalid content_type argument => " . $content_type);
        /**
         * Get target and type variables from the current Campaign.
         */
        $campaign_target = Campaign::getInstance()->getTarget();
        $campaign_type = Campaign::getInstance()->getType();
        try {
            if ($content_type == "completed" && $campaign_type == "globalwords") {
                $file_path1 = AssessmentWriter::writeFile($content_type, $campaign_target, 'global');
                $file_path2 = AssessmentWriter::writeFile($content_type, $campaign_target, 'words');
                return [$file_path1, $file_path2];
            } else {
                return AssessmentWriter::writeFile($content_type, $campaign_target, $campaign_type);
            }
        } catch (Exception $e) {
            LogWriter::addLog("An error has occured while writting completed assessment! " . $e->getMessage());
            return false;
        }
    }

    /**
     * Gets the Assessment object of the Assignation in parameter. An Assessment is abstract
     * and according to the Campaign target, the returned result may be a Snippet or a
     * Document.
     *
     * @param Assignation $e The expert to whom we attribute his next assessment.
     * @return Assessment|false Returns his next Assessment. May returns false if
     * the Expert has no next Assessment.
     */
    public static function assessmentOf(Assignation $a): Assessment|false
    {
        /**
         * Are experts working on snippets or documents? Checking the target of the Campaign...
         * In any case, we need the document id!
         */
        $target = Campaign::getInstance()->getTarget();

        if ($target == "documents")
            return Document::find($a->document_id);

        if ($target == "snippets")
            return Snippet::getSnippet($a->topic_id, $a->document_id);

        throw new Exception("Could not get the next assessment because target didn't match any case (documents or snippets).");
    }

    //*********************
    //***    SETTERS    ***
    //*********************

    protected abstract function __setContent();

    //*********************
    //***    GETTERS    ***
    //*********************

    /**
     * @return String The annotable content of this Assessment.
     */
    public function getAnnotableAbstract(): String
    {
        if (!isset($this->_annotable_abstract)) {
            if (!isset($this->_content))
                $this->__setContent();
            $this->_annotable_abstract = $this->annotableAbstract();
        }
        return $this->_annotable_abstract;
    }

    /**
     * @return String The parsed content of this Assessment.
     */
    public function getParsedAbstract(): String
    {
        if (!isset($this->_annotable_abstract)) {
            if (!isset($this->_content))
                $this->__setContent();
            $this->_parsed_abstract = $this->parseAbstract();
        }
        return $this->_parsed_abstract;
    }
}
